import type { Video } from "@/types/video";

// Interfaces for expected Piped API response structures
interface PipedVideoItem {
  url: string;
  title: string;
  thumbnail: string;
  shortDescription?: string;
  // Add other potential fields if known, e.g., uploaderName, duration, views
}

interface PipedSearchResponse {
  items: PipedVideoItem[];
  // Add other potential fields like nextPage, correctedQuery
}

interface PipedSubtitleInfo {
  url: string;
  // Add other potential fields like code, name, autoGenerated
}
interface PipedStreamData {
  title: string;
  thumbnailUrl: string;
  description: string;
  subtitles?: PipedSubtitleInfo[];
  // Add other potential fields like videoStreams, audioStreams, duration
}

const PIPED_BASE_URL = "https://pipedapi.leptons.xyz";

// Function to extract video ID from a YouTube URL
export function extractVideoId(url: string): string | null {
  if (!url) return null;

  // Check if the input is a URL
  if (!url.includes("youtube.com") && !url.includes("youtu.be")) {
    return null;
  }

  const regExp =
    /^.*((youtu.be\/)|(v\/)|(\/u\/\w\/)|(embed\/)|(watch\?))\??v?=?([^#&?]*).*/;
  const match = url.match(regExp);
  return match && match[7].length === 11 ? match[7] : null;
}

// Function to fetch trending videos
export async function fetchTrendingVideos(
  region = "US",
  page = 1
): Promise<Video[]> {
  try {
    const response = await fetch(`${PIPED_BASE_URL}/trending?region=${region}&page=${page}`);
    if (!response.ok) {
      throw new Error(`Error fetching trending videos: ${response.status} ${response.statusText}`);
    }
    const data: PipedVideoItem[] = await response.json(); // Type the response data
    
    // Need to adapt the Piped API response to the Video type
    // Need to adapt the Piped API response to the Video type
    const videos: Video[] = data.map((item: PipedVideoItem) => ({ // Type the item parameter
      id: item.url.split("=")[1], // Extract video ID from URL
      title: item.title,
      thumbnail: item.thumbnail,
      shortSummary: item.shortDescription || "", // Use shortDescription if available
      longSummary: "", // Piped trending doesn't seem to have a long summary, keep as empty string for now
      transcriptUrl: null,
    }));

    return videos;
  } catch (error) {
    console.error("Error fetching trending videos:", error); // Keep console log for debugging
    throw error; // Re-throw the original error
  }
}

// Function to fetch video details
export async function fetchVideoDetails(videoId: string): Promise<Video | null> {
  try {
    const response = await fetch(`${PIPED_BASE_URL}/streams/${videoId}`);
    if (!response.ok) {
      // Handle 404 specifically as "not found" rather than a generic error
      if (response.status === 404) {
          return null; // Video not found is not necessarily an error state
      }
      throw new Error(`Error fetching video details: ${response.status} ${response.statusText}`);
    }
    const data: PipedStreamData = await response.json(); // Type the response data
    console.log("Raw API response:", data); // Log the raw response

    // Get the first subtitle track (if available)
    const transcript =
      data.subtitles && data.subtitles.length > 0
        ? data.subtitles[0].url
        : null;

    return {
      id: videoId,
      title: data.title,
      thumbnail: data.thumbnailUrl,
      shortSummary: data.description || "",
      longSummary: data.description || "", // Use description for summaries
      transcriptUrl: transcript, // Add a transcript URL
    };
  } catch (error) {
    console.error("Error fetching video details:", error); // Keep console log
    throw error; // Re-throw
  }
}

// Function to search for videos
export async function searchVideos(query: string, isUrl = false, page = 1): Promise<Video[]> {
    try {
      if (isUrl) {
        const videoId = extractVideoId(query);
        if (videoId) {
          const video = await fetchVideoDetails(videoId);
          return video ? [video] : [];
        }
        return [];
      }
  
      const response = await fetch(
        `${PIPED_BASE_URL}/search?q=${encodeURIComponent(query)}&filter=videos&page=${page}`
      );
      if (!response.ok) {
        throw new Error(`Error searching videos: ${response.status} ${response.statusText}`);
      }
      const data: PipedSearchResponse = await response.json(); // Type the response data

      const videos: Video[] = data.items.map((item: PipedVideoItem) => ({ // Type the item parameter
        id: item.url.split("=")[1], // Extract video ID from URL
        title: item.title,
        thumbnail: item.thumbnail,
        shortSummary: item.shortDescription || "", // Handle null shortDescription
        longSummary: "", // No long summary available
        transcriptUrl: null,
      }));

      return videos;
    } catch (error) {
      console.error("Error searching videos:", error); // Keep console log
      throw error; // Re-throw
    }
  }

// Function to fetch videos by topic
export async function fetchVideosByTopic(topic: string, page = 1): Promise<Video[]> {
  try {
    // Using the search endpoint with the topic as the query
    const response = await fetch(
      `${PIPED_BASE_URL}/search?q=${encodeURIComponent(topic)}&filter=videos&page=${page}`
    );
    if (!response.ok) {
      throw new Error(`Error fetching videos by topic ${topic}: ${response.status} ${response.statusText}`);
    }
    const data: PipedSearchResponse = await response.json(); // Type the response data

    const videos: Video[] = data.items.map((item: PipedVideoItem) => ({ // Type the item parameter
      id: item.url.split("=")[1], // Extract video ID from URL
      title: item.title,
      thumbnail: item.thumbnail,
      shortSummary: item.shortDescription || "", // Handle null shortDescription
      longSummary: "", // No long summary available
      transcriptUrl: null,
    }));

    return videos;
  } catch (error) {
    console.error("Error fetching videos by topic:", error); // Keep console log
    throw error; // Re-throw
  }
}

