import type { Video } from "@/types/video";
// Remove unused imports for server-side libraries
// import { generateSummary } from "./ai-summary"; // Summary generation will move to client/modal
// import { YoutubeTranscript } from 'youtube-transcript';
// import YTDlpWrap from 'yt-dlp-wrap';

// Interfaces for expected Piped API response structures (Only needed for trending/search now)
interface PipedVideoItem {
  url: string;
  title: string;
  thumbnail: string;
  shortDescription?: string;
  // Add other potential fields if known, e.g., uploaderName, duration, views
}

interface PipedSearchResponse {
  items: PipedVideoItem[];
  // Add other potential fields like nextPage, correctedQuery
}

interface PipedSubtitleInfo {
  url: string;
  // Add other potential fields like code, name, autoGenerated
}
interface PipedStreamData {
  title: string;
  thumbnailUrl: string;
  description: string;
  subtitles?: PipedSubtitleInfo[];
  // Add other potential fields like videoStreams, audioStreams, duration
}

const PIPED_BASE_URL = "https://pipedapi.leptons.xyz"; // Reverted back to original instance

// Function to extract video ID from a YouTube URL
export function extractVideoId(url: string): string | null {
  if (!url) return null;

  // Check if the input is a URL
  if (!url.includes("youtube.com") && !url.includes("youtu.be")) {
    return null;
  }

  const regExp =
    /^.*((youtu.be\/)|(v\/)|(\/u\/\w\/)|(embed\/)|(watch\?))\??v?=?([^#&?]*).*/;
  const match = url.match(regExp);
  return match && match[7].length === 11 ? match[7] : null;
}

// Function to fetch trending videos
export async function fetchTrendingVideos(
  region = "US",
  page = 1
): Promise<Video[]> {
  try {
    const response = await fetch(`${PIPED_BASE_URL}/trending?region=${region}&page=${page}`);
    if (!response.ok) {
      throw new Error(`Error fetching trending videos: ${response.status} ${response.statusText}`);
    }
    const data: PipedVideoItem[] = await response.json(); // Type the response data
    
    // Need to adapt the Piped API response to the Video type
    // Need to adapt the Piped API response to the Video type
    const videos: Video[] = data.map((item: PipedVideoItem) => ({ // Type the item parameter
      id: item.url.split("=")[1], // Extract video ID from URL
      title: item.title,
      thumbnail: item.thumbnail,
      shortSummary: item.shortDescription || "", // Use shortDescription if available
      longSummary: "", // Piped trending doesn't seem to have a long summary, keep as empty string for now
      transcriptUrl: null,
    }));

    return videos;
  } catch (error) {
    console.error("Error fetching trending videos:", error); // Keep console log for debugging
    throw error; // Re-throw the original error
  }
}

// Function to fetch video details by calling the internal API route
// Note: This function no longer generates the AI summary itself.
// It calls the internal API route to get metadata and transcript content,
// then constructs a full Video object (without the AI summary, which is generated client-side).
export async function fetchVideoDetails(videoId: string): Promise<Video | null> {
  try {
    console.log(`Calling internal API route for video details: /api/video-details/${videoId}`);
    const response = await fetch(`/api/video-details/${videoId}`);

    if (!response.ok) {
      // Attempt to parse error message from API response
      let errorData = null;
      try {
          errorData = await response.json();
      } catch (parseErr) {
          // Ignore if response body isn't valid JSON
      }
      const errorMessage = errorData?.error || `API route failed with status: ${response.status}`;
      console.error(`Error fetching video details from API route for ${videoId}: ${errorMessage}`);
      // Handle specific statuses if needed (e.g., 404 for unavailable)
      if (response.status === 404) {
          console.log(`Video ${videoId} reported as unavailable by API route.`);
      }
      return null; // Return null on API error
    }

    // The API route returns id, title, thumbnail, shortSummary, transcriptContent
    const apiData = await response.json();
    console.log(`Successfully fetched details from API route for ${videoId}`);

    // Construct the full Video object
    const video: Video = {
        id: apiData.id,
        title: apiData.title || "Title not found",
        thumbnail: apiData.thumbnail,
        shortSummary: apiData.shortSummary || "",
        longSummary: apiData.shortSummary || "", // Use shortSummary as fallback for longSummary for now
        transcriptUrl: null, // Not provided by this flow
        transcriptContent: apiData.transcriptContent,
        aiSummary: null, // AI Summary will be generated client-side
    };

    return video;

  } catch (error) {
    console.error(`Network or other error calling internal API route for ${videoId}:`, error);
    return null; // Return null on fetch error
  }
}

// Function to search for videos
export async function searchVideos(query: string, isUrl = false, page = 1): Promise<Video[]> {
    try {
      if (isUrl) {
        const videoId = extractVideoId(query);
        if (videoId) {
          const video = await fetchVideoDetails(videoId);
          return video ? [video] : [];
        }
        return [];
      }
  
      const response = await fetch(
        `${PIPED_BASE_URL}/search?q=${encodeURIComponent(query)}&filter=videos&page=${page}`
      );
      if (!response.ok) {
        throw new Error(`Error searching videos: ${response.status} ${response.statusText}`);
      }
      const data: PipedSearchResponse = await response.json(); // Type the response data

      const videos: Video[] = data.items.map((item: PipedVideoItem) => ({ // Type the item parameter
        id: item.url.split("=")[1], // Extract video ID from URL
        title: item.title,
        thumbnail: item.thumbnail,
        shortSummary: item.shortDescription || "", // Handle null shortDescription
        longSummary: "", // No long summary available
        transcriptUrl: null,
      }));

      return videos;
    } catch (error) {
      console.error("Error searching videos:", error); // Keep console log
      throw error; // Re-throw
    }
  }

// Function to fetch videos by topic
export async function fetchVideosByTopic(topic: string, page = 1): Promise<Video[]> {
  try {
    // Using the search endpoint with the topic as the query
    const response = await fetch(
      `${PIPED_BASE_URL}/search?q=${encodeURIComponent(topic)}&filter=videos&page=${page}`
    );
    if (!response.ok) {
      throw new Error(`Error fetching videos by topic ${topic}: ${response.status} ${response.statusText}`);
    }
    const data: PipedSearchResponse = await response.json(); // Type the response data

    const videos: Video[] = data.items.map((item: PipedVideoItem) => ({ // Type the item parameter
      id: item.url.split("=")[1], // Extract video ID from URL
      title: item.title,
      thumbnail: item.thumbnail,
      shortSummary: item.shortDescription || "", // Handle null shortDescription
      longSummary: "", // No long summary available
      transcriptUrl: null,
    }));

    return videos;
  } catch (error) {
    console.error("Error fetching videos by topic:", error); // Keep console log
    throw error; // Re-throw
  }
}
